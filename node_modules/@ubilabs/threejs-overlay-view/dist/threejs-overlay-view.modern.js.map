{"version":3,"file":"threejs-overlay-view.modern.js","sources":["../src/geo-utils.ts","../src/threejs-overlay-view.ts"],"sourcesContent":["import {MathUtils, Vector3} from 'three';\nimport type {LatLngAltitudeLiteral} from './types';\n\n// shorthands for math-functions, makes equations more readable\nconst {sin, cos, pow, sqrt, atan2, asin, sign} = Math;\nconst {degToRad, radToDeg, euclideanModulo} = MathUtils;\n\nconst EARTH_RADIUS_METERS = 6371008.8;\n\n/**\n * Returns the true bearing (=compass direction) of the point from the origin.\n * @param point\n */\nfunction getTrueBearing(point: Vector3): number {\n  return euclideanModulo(90 - radToDeg(atan2(point.y, point.x)), 360);\n}\n\n/**\n * Computes the distance in meters between two coordinates using the\n * haversine formula.\n * @param from\n * @param to\n */\nfunction distance(\n  from: google.maps.LatLngLiteral,\n  to: google.maps.LatLngLiteral\n): number {\n  const {lat: latFrom, lng: lngFrom} = from;\n  const {lat: latTo, lng: lngTo} = to;\n\n  const dLat = degToRad(latTo - latFrom);\n  const dLon = degToRad(lngTo - lngFrom);\n  const lat1 = degToRad(latFrom);\n  const lat2 = degToRad(latTo);\n\n  const a =\n    pow(sin(dLat / 2), 2) + pow(sin(dLon / 2), 2) * cos(lat1) * cos(lat2);\n\n  return 2 * atan2(sqrt(a), sqrt(1 - a)) * EARTH_RADIUS_METERS;\n}\n\n/**\n * Computes a destination-point from a geographic origin, distance\n * and true bearing.\n * @param origin\n * @param distance\n * @param bearing\n * @param target optional target to write the result to\n */\nfunction destination(\n  origin: google.maps.LatLngLiteral,\n  distance: number,\n  bearing: number,\n  target: google.maps.LatLngLiteral = {lat: 0, lng: 0}\n): google.maps.LatLngLiteral {\n  const lngOrigin = degToRad(origin.lng);\n  const latOrigin = degToRad(origin.lat);\n\n  const bearingRad = degToRad(bearing);\n  const radians = distance / EARTH_RADIUS_METERS;\n\n  const latDestination = asin(\n    sin(latOrigin) * cos(radians) +\n      cos(latOrigin) * sin(radians) * cos(bearingRad)\n  );\n  const lngDestination =\n    lngOrigin +\n    atan2(\n      sin(bearingRad) * sin(radians) * cos(latOrigin),\n      cos(radians) - sin(latOrigin) * sin(latDestination)\n    );\n\n  target.lat = radToDeg(latDestination);\n  target.lng = radToDeg(lngDestination);\n\n  return target;\n}\n\n/**\n * Converts a point given in lat/lng or lat/lng/altitude-format to world-space coordinates.\n * @param point\n * @param reference\n * @param target optional target to write the result to\n */\nexport function latLngAltToVector3(\n  point: LatLngAltitudeLiteral | google.maps.LatLngLiteral,\n  reference: LatLngAltitudeLiteral,\n  target: Vector3 = new Vector3()\n): Vector3 {\n  const dx = distance(reference, {lng: point.lng, lat: reference.lat});\n  const dy = distance(reference, {lng: reference.lng, lat: point.lat});\n\n  const sx = sign(point.lng - reference.lng);\n  const sy = sign(point.lat - reference.lat);\n\n  const {altitude = 0} = <LatLngAltitudeLiteral>point;\n\n  return target.set(sx * dx, sy * dy, altitude);\n}\n\n/**\n * Converts a point given in world-space coordinates into geographic format.\n * @param point\n * @param sceneAnchor\n * @param target optional target to write the result to\n */\nexport function vector3ToLatLngAlt(\n  point: Vector3,\n  sceneAnchor: LatLngAltitudeLiteral,\n  target: LatLngAltitudeLiteral = {lat: 0, lng: 0, altitude: 0}\n): LatLngAltitudeLiteral {\n  const distance = point.length();\n  const bearing = getTrueBearing(point);\n\n  destination(sceneAnchor, distance, bearing, target);\n  target.altitude = point.z;\n\n  return target;\n}\n","import {\n  DirectionalLight,\n  HemisphereLight,\n  Intersection,\n  Matrix4,\n  Object3D,\n  PerspectiveCamera,\n  Raycaster,\n  Scene,\n  Vector2,\n  Vector3,\n  WebGL1Renderer\n} from 'three';\n\nimport {latLngAltToVector3, vector3ToLatLngAlt} from './geo-utils';\n\nimport type {LatLngAltitudeLiteral, RaycastOptions} from './types';\n\nconst projectionMatrixInverse = new Matrix4();\n\n/**\n * A wrapper for google.maps.WebGLOverlayView handling the details of the\n * integration with three.js.\n */\nexport default class ThreeJSOverlayView {\n  /**\n   * The WebGLOverlayView instance being used. Aggregation is used instead\n   * of extending the class to allow for this class to be parsed before the\n   * google-maps API has been loaded.\n   */\n  protected readonly overlay: google.maps.WebGLOverlayView;\n\n  /**\n   * The three.js camera-instance. When interacting with this camera it is\n   * important to know that the world-matrix doesn't contain any useful\n   * information. Position and orientation of the camera are instead part\n   * of the projectionMatrix.\n   */\n  protected readonly camera: PerspectiveCamera;\n\n  /**\n   * The three.js renderer instance. This is initialized in the\n   * onContextRestored-callback.\n   */\n  protected renderer: WebGL1Renderer | null;\n\n  /**\n   * The three.js Scene instance.\n   */\n  protected scene: Scene;\n\n  /**\n   * The geographic reference-point in latitude/longitude/altitude above ground.\n   */\n  protected referencePoint: LatLngAltitudeLiteral;\n\n  /**\n   * The viewport size used by the renderer, this is always kept up-to-date.\n   */\n  protected viewportSize: Vector2 = new Vector2();\n\n  /**\n   * The raycaster used by the `raycast()` method.\n   */\n  protected raycaster: Raycaster = new Raycaster();\n\n  /**\n   * This callback is called when the overlay has been added to the map, but\n   * before it is first rendered.\n   */\n  onAdd: (() => void) | null = null;\n\n  /**\n   * This callback is called after the overlay has been removed from the map.\n   */\n  onRemove: (() => void) | null = null;\n\n  /**\n   * This callback is called for every frame being rendered.\n   */\n  update: (() => void) | null = null;\n\n  /**\n   * Creates a new ThreejsOverlayView with the specified origin-point.\n   * @param referencePoint\n   */\n  constructor(\n    referencePoint: LatLngAltitudeLiteral | google.maps.LatLngLiteral\n  ) {\n    this.referencePoint = {altitude: 0, ...referencePoint};\n    this.overlay = this.initWebGLOverlayView();\n    this.renderer = null;\n    this.scene = this.initScene();\n    this.camera = new PerspectiveCamera();\n  }\n\n  /**\n   * Sets the map-instance this overlay should be shown on.\n   */\n  setMap(map: google.maps.Map) {\n    this.overlay.setMap(map);\n  }\n\n  /**\n   * Sets the geographic coordinates of the reference point where the scene will\n   * have it's origin.\n   * @param referencePoint\n   */\n  setReferencePoint(\n    referencePoint: LatLngAltitudeLiteral | google.maps.LatLngLiteral\n  ) {\n    this.referencePoint = {altitude: 0, ...referencePoint};\n  }\n\n  /**\n   * Returns the scene-instance that is rendered on the map.\n   */\n  getScene(): Scene {\n    return this.scene;\n  }\n\n  /**\n   * Returns the viewport-size used by the map and the three.js renderer.\n   */\n  getViewportSize(): Vector2 {\n    return this.viewportSize;\n  }\n\n  /**\n   * Requests a full redraw of the map and all overlays for the next frame.\n   *\n   * This has to be called whenever changes to the scene were made to make\n   * sure they are actually rendered.\n   */\n  requestRedraw() {\n    this.overlay.requestRedraw();\n  }\n\n  /**\n   * Runs raycasting for the specified screen-coordinate against the scene\n   * or the optionally specified list of objects.\n   * @param normalizedScreenPoint the screen-coordinates, x/y in range [-1, 1],\n   *   y pointing up.\n   * @param objects optional list of objects to consider, raycasts against the\n   *   complete scene if none are specified\n   * @param options.recursive set to true to also check children of the specified\n   *   objects for intersections. Only applies when a list of objects is\n   *   specified.\n   * @param options.updateMatrix set this to false to skip updating the\n   *   inverse-projection-matrix (useful if you need to run multiple\n   *   raycasts for the same frame).\n   * @param options.raycasterParameters parameters to pass on to the raycaster\n   * @return returns the list of intersections\n   */\n  raycast(\n    normalizedScreenPoint: Vector2,\n    objects: Object3D | Object3D[] | null = null,\n    options: RaycastOptions = {updateMatrix: true, recursive: false}\n  ): Intersection[] {\n    let {updateMatrix, recursive, raycasterParameters} = options;\n\n    // the mvp-matrix used to render the previous frame is still stored in\n    // this.camera.projectionMatrix so we don't need to recompute it. That\n    // matrix would transform meters in our world-space (relative to\n    // this.referencePoint) to clip-space/NDC coordinates. The inverse matrix\n    // created here does the exact opposite and convert NDC-coordinates to\n    // world-space\n    if (updateMatrix) {\n      projectionMatrixInverse.copy(this.camera.projectionMatrix).invert();\n    }\n\n    // create two points  with different depth from the mouse-position and\n    // convert to world-space to setup the ray.\n    this.raycaster.ray.origin\n      .set(normalizedScreenPoint.x, normalizedScreenPoint.y, 0)\n      .applyMatrix4(projectionMatrixInverse);\n\n    this.raycaster.ray.direction\n      .set(normalizedScreenPoint.x, normalizedScreenPoint.y, 0.5)\n      .applyMatrix4(projectionMatrixInverse)\n      .sub(this.raycaster.ray.origin)\n      .normalize();\n\n    let oldRaycasterParams = this.raycaster.params;\n    if (raycasterParameters) {\n      this.raycaster.params = raycasterParameters;\n    }\n\n    if (objects === null) {\n      objects = this.scene;\n      recursive = true;\n    }\n\n    const results = Array.isArray(objects)\n      ? this.raycaster.intersectObjects(objects, recursive)\n      : this.raycaster.intersectObject(objects, recursive);\n\n    // reset raycaster params to whatever they were before\n    this.raycaster.params = oldRaycasterParams;\n\n    return results;\n  }\n\n  /**\n   * Converts geographic coordinates into world-space coordinates.\n   * Optionally accepts a Vector3 instance as second parameter to write the value to.\n   * @param point\n   * @param target optional target the result will be written to\n   */\n  latLngAltToVector3(\n    point: LatLngAltitudeLiteral | google.maps.LatLngLiteral,\n    target: Vector3 = new Vector3()\n  ): Vector3 {\n    return latLngAltToVector3(point, this.referencePoint, target);\n  }\n\n  /**\n   * Converts world-space coordinates to geographic coordinates.\n   * Optionally accepts a LatLngAltitudeLiteral instance to write the value to.\n   * @param point\n   * @param target optional target the result will be written to\n   */\n  vector3ToLatLngAlt(\n    point: Vector3,\n    target: LatLngAltitudeLiteral = {lat: 0, lng: 0, altitude: 0}\n  ): LatLngAltitudeLiteral {\n    return vector3ToLatLngAlt(point, this.referencePoint, target);\n  }\n\n  /**\n   * Initializes the threejs-renderer when the rendering-context becomes available.\n   * @param gl\n   */\n  protected onContextRestored(stateOptions: google.maps.WebGLStateOptions) {\n    const {gl} = stateOptions;\n    const mapGlCanvas = gl.canvas as HTMLCanvasElement;\n\n    let renderer = new WebGL1Renderer({\n      canvas: mapGlCanvas,\n      context: gl,\n      ...gl.getContextAttributes()\n    });\n\n    renderer.autoClear = false;\n    renderer.autoClearDepth = false;\n\n    const {width, height} = <HTMLCanvasElement>gl.canvas;\n    this.viewportSize.set(width, height);\n    this.renderer = renderer;\n  }\n\n  /**\n   * Cleans up and destroy the renderer when the context becomes invalid.\n   */\n  protected onContextLost() {\n    if (!this.renderer) {\n      return;\n    }\n\n    this.viewportSize.set(0, 0);\n    this.renderer.dispose();\n    this.renderer = null;\n  }\n\n  /**\n   * Renders a new frame. Is called by the maps-api when the camera parameters\n   * changed or a redraw was requested.\n   * @param gl\n   * @param transformer\n   */\n\n  protected onDraw(drawOptions: google.maps.WebGLDrawOptions) {\n    const {gl, transformer} = drawOptions;\n\n    if (!this.scene || !this.renderer) {\n      return;\n    }\n\n    // fix: this appears to be a bug in the maps-API. onDraw will\n    //   continue to be called by the api after it has been removed\n    //   from the map. We should remove this once fixed upstream.\n    if (this.overlay.getMap() === null) {\n      return;\n    }\n\n    this.camera.projectionMatrix.fromArray(\n      transformer.fromLatLngAltitude(this.referencePoint)\n    );\n\n    const {width, height} = <HTMLCanvasElement>gl.canvas;\n    this.viewportSize.set(width, height);\n    this.renderer.setViewport(0, 0, width, height);\n\n    if (this.update) {\n      this.update();\n    }\n\n    this.renderer.render(this.scene, this.camera);\n    this.renderer.resetState();\n  }\n\n  /**\n   * Initializes the scene with basic lighting that mimics the lighting used for\n   * the buildings on the map.\n   *\n   * At some point it might be possible to retrieve information about the actual lighting\n   * used for the buildings (which is dependent on time-of-day) from the api, which\n   * is why the light-setup is handled by the ThreejsOverlayView.\n   */\n  protected initScene(): Scene {\n    const scene = new Scene();\n\n    // create two three.js lights to illuminate the model (roughly approximates\n    // the lighting of buildings in maps)\n    const hemiLight = new HemisphereLight(0xffffff, 0x444444, 1);\n    hemiLight.position.set(0, -0.2, 1).normalize();\n\n    const dirLight = new DirectionalLight(0xffffff);\n    dirLight.position.set(0, 10, 100);\n\n    scene.add(hemiLight, dirLight);\n\n    return scene;\n  }\n\n  /**\n   * Creates the google.maps.WebGLOverlayView instance\n   */\n  protected initWebGLOverlayView(): google.maps.WebGLOverlayView {\n    if (!google || !google.maps) {\n      throw new Error(\n        'Google Maps API not loaded. Please make sure to create the ' +\n          'overlay after the API has been loaded.'\n      );\n    }\n\n    if (!google.maps.WebGLOverlayView) {\n      throw new Error(\n        'WebGLOverlayView not found. Please make sure to load the ' +\n          'beta-channel of the Google Maps API.'\n      );\n    }\n\n    const overlay = new google.maps.WebGLOverlayView();\n\n    overlay.onAdd = wrapExceptionLogger(() => {\n      if (this.onAdd === null) return;\n      this.onAdd();\n    });\n\n    overlay.onRemove = wrapExceptionLogger(() => {\n      if (this.onRemove === null) return;\n      this.onRemove();\n    });\n\n    overlay.onDraw = wrapExceptionLogger(this.onDraw.bind(this));\n\n    overlay.onContextRestored = wrapExceptionLogger(\n      this.onContextRestored.bind(this)\n    );\n\n    overlay.onContextLost = wrapExceptionLogger(this.onContextLost.bind(this));\n\n    return overlay;\n  }\n}\n\n// (hopefully) temporary solution to make sure exceptions wont be silently ignored.\nfunction wrapExceptionLogger<T extends Function>(fn: T): T {\n  return ((...args: any[]) => {\n    try {\n      return fn(...args);\n    } catch (err) {\n      console.error(err);\n      throw err;\n    }\n  }) as any;\n}\n"],"names":["sin","cos","pow","sqrt","atan2","asin","sign","Math","degToRad","radToDeg","euclideanModulo","MathUtils","distance","from","to","lat","latFrom","lng","lngFrom","latTo","lngTo","dLat","dLon","lat1","lat2","a","projectionMatrixInverse","Matrix4","wrapExceptionLogger","fn","args","err","console","error","constructor","referencePoint","overlay","camera","renderer","scene","viewportSize","Vector2","raycaster","Raycaster","onAdd","onRemove","update","this","altitude","initWebGLOverlayView","initScene","PerspectiveCamera","setMap","map","setReferencePoint","getScene","getViewportSize","requestRedraw","raycast","normalizedScreenPoint","objects","options","updateMatrix","recursive","raycasterParameters","copy","projectionMatrix","invert","ray","origin","set","x","y","applyMatrix4","direction","sub","normalize","oldRaycasterParams","params","results","Array","isArray","intersectObjects","intersectObject","latLngAltToVector3","point","target","Vector3","reference","dx","dy","sx","sy","vector3ToLatLngAlt","sceneAnchor","bearing","lngOrigin","latOrigin","bearingRad","radians","latDestination","lngDestination","destination","length","getTrueBearing","z","onContextRestored","stateOptions","gl","WebGL1Renderer","canvas","context","getContextAttributes","autoClear","autoClearDepth","width","height","onContextLost","dispose","onDraw","drawOptions","transformer","getMap","fromArray","fromLatLngAltitude","setViewport","render","resetState","Scene","hemiLight","HemisphereLight","position","dirLight","DirectionalLight","add","google","maps","Error","WebGLOverlayView","bind"],"mappings":"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"}