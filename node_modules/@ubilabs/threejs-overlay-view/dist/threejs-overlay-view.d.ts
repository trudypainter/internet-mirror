/// <reference types="google.maps" />
import { Intersection, Object3D, PerspectiveCamera, Raycaster, Scene, Vector2, Vector3, WebGL1Renderer } from 'three';
import type { LatLngAltitudeLiteral, RaycastOptions } from './types';
/**
 * A wrapper for google.maps.WebGLOverlayView handling the details of the
 * integration with three.js.
 */
export default class ThreeJSOverlayView {
    /**
     * The WebGLOverlayView instance being used. Aggregation is used instead
     * of extending the class to allow for this class to be parsed before the
     * google-maps API has been loaded.
     */
    protected readonly overlay: google.maps.WebGLOverlayView;
    /**
     * The three.js camera-instance. When interacting with this camera it is
     * important to know that the world-matrix doesn't contain any useful
     * information. Position and orientation of the camera are instead part
     * of the projectionMatrix.
     */
    protected readonly camera: PerspectiveCamera;
    /**
     * The three.js renderer instance. This is initialized in the
     * onContextRestored-callback.
     */
    protected renderer: WebGL1Renderer | null;
    /**
     * The three.js Scene instance.
     */
    protected scene: Scene;
    /**
     * The geographic reference-point in latitude/longitude/altitude above ground.
     */
    protected referencePoint: LatLngAltitudeLiteral;
    /**
     * The viewport size used by the renderer, this is always kept up-to-date.
     */
    protected viewportSize: Vector2;
    /**
     * The raycaster used by the `raycast()` method.
     */
    protected raycaster: Raycaster;
    /**
     * This callback is called when the overlay has been added to the map, but
     * before it is first rendered.
     */
    onAdd: (() => void) | null;
    /**
     * This callback is called after the overlay has been removed from the map.
     */
    onRemove: (() => void) | null;
    /**
     * This callback is called for every frame being rendered.
     */
    update: (() => void) | null;
    /**
     * Creates a new ThreejsOverlayView with the specified origin-point.
     * @param referencePoint
     */
    constructor(referencePoint: LatLngAltitudeLiteral | google.maps.LatLngLiteral);
    /**
     * Sets the map-instance this overlay should be shown on.
     */
    setMap(map: google.maps.Map): void;
    /**
     * Sets the geographic coordinates of the reference point where the scene will
     * have it's origin.
     * @param referencePoint
     */
    setReferencePoint(referencePoint: LatLngAltitudeLiteral | google.maps.LatLngLiteral): void;
    /**
     * Returns the scene-instance that is rendered on the map.
     */
    getScene(): Scene;
    /**
     * Returns the viewport-size used by the map and the three.js renderer.
     */
    getViewportSize(): Vector2;
    /**
     * Requests a full redraw of the map and all overlays for the next frame.
     *
     * This has to be called whenever changes to the scene were made to make
     * sure they are actually rendered.
     */
    requestRedraw(): void;
    /**
     * Runs raycasting for the specified screen-coordinate against the scene
     * or the optionally specified list of objects.
     * @param normalizedScreenPoint the screen-coordinates, x/y in range [-1, 1],
     *   y pointing up.
     * @param objects optional list of objects to consider, raycasts against the
     *   complete scene if none are specified
     * @param options.recursive set to true to also check children of the specified
     *   objects for intersections. Only applies when a list of objects is
     *   specified.
     * @param options.updateMatrix set this to false to skip updating the
     *   inverse-projection-matrix (useful if you need to run multiple
     *   raycasts for the same frame).
     * @param options.raycasterParameters parameters to pass on to the raycaster
     * @return returns the list of intersections
     */
    raycast(normalizedScreenPoint: Vector2, objects?: Object3D | Object3D[] | null, options?: RaycastOptions): Intersection[];
    /**
     * Converts geographic coordinates into world-space coordinates.
     * Optionally accepts a Vector3 instance as second parameter to write the value to.
     * @param point
     * @param target optional target the result will be written to
     */
    latLngAltToVector3(point: LatLngAltitudeLiteral | google.maps.LatLngLiteral, target?: Vector3): Vector3;
    /**
     * Converts world-space coordinates to geographic coordinates.
     * Optionally accepts a LatLngAltitudeLiteral instance to write the value to.
     * @param point
     * @param target optional target the result will be written to
     */
    vector3ToLatLngAlt(point: Vector3, target?: LatLngAltitudeLiteral): LatLngAltitudeLiteral;
    /**
     * Initializes the threejs-renderer when the rendering-context becomes available.
     * @param gl
     */
    protected onContextRestored(stateOptions: google.maps.WebGLStateOptions): void;
    /**
     * Cleans up and destroy the renderer when the context becomes invalid.
     */
    protected onContextLost(): void;
    /**
     * Renders a new frame. Is called by the maps-api when the camera parameters
     * changed or a redraw was requested.
     * @param gl
     * @param transformer
     */
    protected onDraw(drawOptions: google.maps.WebGLDrawOptions): void;
    /**
     * Initializes the scene with basic lighting that mimics the lighting used for
     * the buildings on the map.
     *
     * At some point it might be possible to retrieve information about the actual lighting
     * used for the buildings (which is dependent on time-of-day) from the api, which
     * is why the light-setup is handled by the ThreejsOverlayView.
     */
    protected initScene(): Scene;
    /**
     * Creates the google.maps.WebGLOverlayView instance
     */
    protected initWebGLOverlayView(): google.maps.WebGLOverlayView;
}
