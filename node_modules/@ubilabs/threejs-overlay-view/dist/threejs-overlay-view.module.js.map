{"version":3,"file":"threejs-overlay-view.module.js","sources":["../src/geo-utils.ts","../src/threejs-overlay-view.ts"],"sourcesContent":["import {MathUtils, Vector3} from 'three';\nimport type {LatLngAltitudeLiteral} from './types';\n\n// shorthands for math-functions, makes equations more readable\nconst {sin, cos, pow, sqrt, atan2, asin, sign} = Math;\nconst {degToRad, radToDeg, euclideanModulo} = MathUtils;\n\nconst EARTH_RADIUS_METERS = 6371008.8;\n\n/**\n * Returns the true bearing (=compass direction) of the point from the origin.\n * @param point\n */\nfunction getTrueBearing(point: Vector3): number {\n  return euclideanModulo(90 - radToDeg(atan2(point.y, point.x)), 360);\n}\n\n/**\n * Computes the distance in meters between two coordinates using the\n * haversine formula.\n * @param from\n * @param to\n */\nfunction distance(\n  from: google.maps.LatLngLiteral,\n  to: google.maps.LatLngLiteral\n): number {\n  const {lat: latFrom, lng: lngFrom} = from;\n  const {lat: latTo, lng: lngTo} = to;\n\n  const dLat = degToRad(latTo - latFrom);\n  const dLon = degToRad(lngTo - lngFrom);\n  const lat1 = degToRad(latFrom);\n  const lat2 = degToRad(latTo);\n\n  const a =\n    pow(sin(dLat / 2), 2) + pow(sin(dLon / 2), 2) * cos(lat1) * cos(lat2);\n\n  return 2 * atan2(sqrt(a), sqrt(1 - a)) * EARTH_RADIUS_METERS;\n}\n\n/**\n * Computes a destination-point from a geographic origin, distance\n * and true bearing.\n * @param origin\n * @param distance\n * @param bearing\n * @param target optional target to write the result to\n */\nfunction destination(\n  origin: google.maps.LatLngLiteral,\n  distance: number,\n  bearing: number,\n  target: google.maps.LatLngLiteral = {lat: 0, lng: 0}\n): google.maps.LatLngLiteral {\n  const lngOrigin = degToRad(origin.lng);\n  const latOrigin = degToRad(origin.lat);\n\n  const bearingRad = degToRad(bearing);\n  const radians = distance / EARTH_RADIUS_METERS;\n\n  const latDestination = asin(\n    sin(latOrigin) * cos(radians) +\n      cos(latOrigin) * sin(radians) * cos(bearingRad)\n  );\n  const lngDestination =\n    lngOrigin +\n    atan2(\n      sin(bearingRad) * sin(radians) * cos(latOrigin),\n      cos(radians) - sin(latOrigin) * sin(latDestination)\n    );\n\n  target.lat = radToDeg(latDestination);\n  target.lng = radToDeg(lngDestination);\n\n  return target;\n}\n\n/**\n * Converts a point given in lat/lng or lat/lng/altitude-format to world-space coordinates.\n * @param point\n * @param reference\n * @param target optional target to write the result to\n */\nexport function latLngAltToVector3(\n  point: LatLngAltitudeLiteral | google.maps.LatLngLiteral,\n  reference: LatLngAltitudeLiteral,\n  target: Vector3 = new Vector3()\n): Vector3 {\n  const dx = distance(reference, {lng: point.lng, lat: reference.lat});\n  const dy = distance(reference, {lng: reference.lng, lat: point.lat});\n\n  const sx = sign(point.lng - reference.lng);\n  const sy = sign(point.lat - reference.lat);\n\n  const {altitude = 0} = <LatLngAltitudeLiteral>point;\n\n  return target.set(sx * dx, sy * dy, altitude);\n}\n\n/**\n * Converts a point given in world-space coordinates into geographic format.\n * @param point\n * @param sceneAnchor\n * @param target optional target to write the result to\n */\nexport function vector3ToLatLngAlt(\n  point: Vector3,\n  sceneAnchor: LatLngAltitudeLiteral,\n  target: LatLngAltitudeLiteral = {lat: 0, lng: 0, altitude: 0}\n): LatLngAltitudeLiteral {\n  const distance = point.length();\n  const bearing = getTrueBearing(point);\n\n  destination(sceneAnchor, distance, bearing, target);\n  target.altitude = point.z;\n\n  return target;\n}\n","import {\n  DirectionalLight,\n  HemisphereLight,\n  Intersection,\n  Matrix4,\n  Object3D,\n  PerspectiveCamera,\n  Raycaster,\n  Scene,\n  Vector2,\n  Vector3,\n  WebGL1Renderer\n} from 'three';\n\nimport {latLngAltToVector3, vector3ToLatLngAlt} from './geo-utils';\n\nimport type {LatLngAltitudeLiteral, RaycastOptions} from './types';\n\nconst projectionMatrixInverse = new Matrix4();\n\n/**\n * A wrapper for google.maps.WebGLOverlayView handling the details of the\n * integration with three.js.\n */\nexport default class ThreeJSOverlayView {\n  /**\n   * The WebGLOverlayView instance being used. Aggregation is used instead\n   * of extending the class to allow for this class to be parsed before the\n   * google-maps API has been loaded.\n   */\n  protected readonly overlay: google.maps.WebGLOverlayView;\n\n  /**\n   * The three.js camera-instance. When interacting with this camera it is\n   * important to know that the world-matrix doesn't contain any useful\n   * information. Position and orientation of the camera are instead part\n   * of the projectionMatrix.\n   */\n  protected readonly camera: PerspectiveCamera;\n\n  /**\n   * The three.js renderer instance. This is initialized in the\n   * onContextRestored-callback.\n   */\n  protected renderer: WebGL1Renderer | null;\n\n  /**\n   * The three.js Scene instance.\n   */\n  protected scene: Scene;\n\n  /**\n   * The geographic reference-point in latitude/longitude/altitude above ground.\n   */\n  protected referencePoint: LatLngAltitudeLiteral;\n\n  /**\n   * The viewport size used by the renderer, this is always kept up-to-date.\n   */\n  protected viewportSize: Vector2 = new Vector2();\n\n  /**\n   * The raycaster used by the `raycast()` method.\n   */\n  protected raycaster: Raycaster = new Raycaster();\n\n  /**\n   * This callback is called when the overlay has been added to the map, but\n   * before it is first rendered.\n   */\n  onAdd: (() => void) | null = null;\n\n  /**\n   * This callback is called after the overlay has been removed from the map.\n   */\n  onRemove: (() => void) | null = null;\n\n  /**\n   * This callback is called for every frame being rendered.\n   */\n  update: (() => void) | null = null;\n\n  /**\n   * Creates a new ThreejsOverlayView with the specified origin-point.\n   * @param referencePoint\n   */\n  constructor(\n    referencePoint: LatLngAltitudeLiteral | google.maps.LatLngLiteral\n  ) {\n    this.referencePoint = {altitude: 0, ...referencePoint};\n    this.overlay = this.initWebGLOverlayView();\n    this.renderer = null;\n    this.scene = this.initScene();\n    this.camera = new PerspectiveCamera();\n  }\n\n  /**\n   * Sets the map-instance this overlay should be shown on.\n   */\n  setMap(map: google.maps.Map) {\n    this.overlay.setMap(map);\n  }\n\n  /**\n   * Sets the geographic coordinates of the reference point where the scene will\n   * have it's origin.\n   * @param referencePoint\n   */\n  setReferencePoint(\n    referencePoint: LatLngAltitudeLiteral | google.maps.LatLngLiteral\n  ) {\n    this.referencePoint = {altitude: 0, ...referencePoint};\n  }\n\n  /**\n   * Returns the scene-instance that is rendered on the map.\n   */\n  getScene(): Scene {\n    return this.scene;\n  }\n\n  /**\n   * Returns the viewport-size used by the map and the three.js renderer.\n   */\n  getViewportSize(): Vector2 {\n    return this.viewportSize;\n  }\n\n  /**\n   * Requests a full redraw of the map and all overlays for the next frame.\n   *\n   * This has to be called whenever changes to the scene were made to make\n   * sure they are actually rendered.\n   */\n  requestRedraw() {\n    this.overlay.requestRedraw();\n  }\n\n  /**\n   * Runs raycasting for the specified screen-coordinate against the scene\n   * or the optionally specified list of objects.\n   * @param normalizedScreenPoint the screen-coordinates, x/y in range [-1, 1],\n   *   y pointing up.\n   * @param objects optional list of objects to consider, raycasts against the\n   *   complete scene if none are specified\n   * @param options.recursive set to true to also check children of the specified\n   *   objects for intersections. Only applies when a list of objects is\n   *   specified.\n   * @param options.updateMatrix set this to false to skip updating the\n   *   inverse-projection-matrix (useful if you need to run multiple\n   *   raycasts for the same frame).\n   * @param options.raycasterParameters parameters to pass on to the raycaster\n   * @return returns the list of intersections\n   */\n  raycast(\n    normalizedScreenPoint: Vector2,\n    objects: Object3D | Object3D[] | null = null,\n    options: RaycastOptions = {updateMatrix: true, recursive: false}\n  ): Intersection[] {\n    let {updateMatrix, recursive, raycasterParameters} = options;\n\n    // the mvp-matrix used to render the previous frame is still stored in\n    // this.camera.projectionMatrix so we don't need to recompute it. That\n    // matrix would transform meters in our world-space (relative to\n    // this.referencePoint) to clip-space/NDC coordinates. The inverse matrix\n    // created here does the exact opposite and convert NDC-coordinates to\n    // world-space\n    if (updateMatrix) {\n      projectionMatrixInverse.copy(this.camera.projectionMatrix).invert();\n    }\n\n    // create two points  with different depth from the mouse-position and\n    // convert to world-space to setup the ray.\n    this.raycaster.ray.origin\n      .set(normalizedScreenPoint.x, normalizedScreenPoint.y, 0)\n      .applyMatrix4(projectionMatrixInverse);\n\n    this.raycaster.ray.direction\n      .set(normalizedScreenPoint.x, normalizedScreenPoint.y, 0.5)\n      .applyMatrix4(projectionMatrixInverse)\n      .sub(this.raycaster.ray.origin)\n      .normalize();\n\n    let oldRaycasterParams = this.raycaster.params;\n    if (raycasterParameters) {\n      this.raycaster.params = raycasterParameters;\n    }\n\n    if (objects === null) {\n      objects = this.scene;\n      recursive = true;\n    }\n\n    const results = Array.isArray(objects)\n      ? this.raycaster.intersectObjects(objects, recursive)\n      : this.raycaster.intersectObject(objects, recursive);\n\n    // reset raycaster params to whatever they were before\n    this.raycaster.params = oldRaycasterParams;\n\n    return results;\n  }\n\n  /**\n   * Converts geographic coordinates into world-space coordinates.\n   * Optionally accepts a Vector3 instance as second parameter to write the value to.\n   * @param point\n   * @param target optional target the result will be written to\n   */\n  latLngAltToVector3(\n    point: LatLngAltitudeLiteral | google.maps.LatLngLiteral,\n    target: Vector3 = new Vector3()\n  ): Vector3 {\n    return latLngAltToVector3(point, this.referencePoint, target);\n  }\n\n  /**\n   * Converts world-space coordinates to geographic coordinates.\n   * Optionally accepts a LatLngAltitudeLiteral instance to write the value to.\n   * @param point\n   * @param target optional target the result will be written to\n   */\n  vector3ToLatLngAlt(\n    point: Vector3,\n    target: LatLngAltitudeLiteral = {lat: 0, lng: 0, altitude: 0}\n  ): LatLngAltitudeLiteral {\n    return vector3ToLatLngAlt(point, this.referencePoint, target);\n  }\n\n  /**\n   * Initializes the threejs-renderer when the rendering-context becomes available.\n   * @param gl\n   */\n  protected onContextRestored(stateOptions: google.maps.WebGLStateOptions) {\n    const {gl} = stateOptions;\n    const mapGlCanvas = gl.canvas as HTMLCanvasElement;\n\n    let renderer = new WebGL1Renderer({\n      canvas: mapGlCanvas,\n      context: gl,\n      ...gl.getContextAttributes()\n    });\n\n    renderer.autoClear = false;\n    renderer.autoClearDepth = false;\n\n    const {width, height} = <HTMLCanvasElement>gl.canvas;\n    this.viewportSize.set(width, height);\n    this.renderer = renderer;\n  }\n\n  /**\n   * Cleans up and destroy the renderer when the context becomes invalid.\n   */\n  protected onContextLost() {\n    if (!this.renderer) {\n      return;\n    }\n\n    this.viewportSize.set(0, 0);\n    this.renderer.dispose();\n    this.renderer = null;\n  }\n\n  /**\n   * Renders a new frame. Is called by the maps-api when the camera parameters\n   * changed or a redraw was requested.\n   * @param gl\n   * @param transformer\n   */\n\n  protected onDraw(drawOptions: google.maps.WebGLDrawOptions) {\n    const {gl, transformer} = drawOptions;\n\n    if (!this.scene || !this.renderer) {\n      return;\n    }\n\n    // fix: this appears to be a bug in the maps-API. onDraw will\n    //   continue to be called by the api after it has been removed\n    //   from the map. We should remove this once fixed upstream.\n    if (this.overlay.getMap() === null) {\n      return;\n    }\n\n    this.camera.projectionMatrix.fromArray(\n      transformer.fromLatLngAltitude(this.referencePoint)\n    );\n\n    const {width, height} = <HTMLCanvasElement>gl.canvas;\n    this.viewportSize.set(width, height);\n    this.renderer.setViewport(0, 0, width, height);\n\n    if (this.update) {\n      this.update();\n    }\n\n    this.renderer.render(this.scene, this.camera);\n    this.renderer.resetState();\n  }\n\n  /**\n   * Initializes the scene with basic lighting that mimics the lighting used for\n   * the buildings on the map.\n   *\n   * At some point it might be possible to retrieve information about the actual lighting\n   * used for the buildings (which is dependent on time-of-day) from the api, which\n   * is why the light-setup is handled by the ThreejsOverlayView.\n   */\n  protected initScene(): Scene {\n    const scene = new Scene();\n\n    // create two three.js lights to illuminate the model (roughly approximates\n    // the lighting of buildings in maps)\n    const hemiLight = new HemisphereLight(0xffffff, 0x444444, 1);\n    hemiLight.position.set(0, -0.2, 1).normalize();\n\n    const dirLight = new DirectionalLight(0xffffff);\n    dirLight.position.set(0, 10, 100);\n\n    scene.add(hemiLight, dirLight);\n\n    return scene;\n  }\n\n  /**\n   * Creates the google.maps.WebGLOverlayView instance\n   */\n  protected initWebGLOverlayView(): google.maps.WebGLOverlayView {\n    if (!google || !google.maps) {\n      throw new Error(\n        'Google Maps API not loaded. Please make sure to create the ' +\n          'overlay after the API has been loaded.'\n      );\n    }\n\n    if (!google.maps.WebGLOverlayView) {\n      throw new Error(\n        'WebGLOverlayView not found. Please make sure to load the ' +\n          'beta-channel of the Google Maps API.'\n      );\n    }\n\n    const overlay = new google.maps.WebGLOverlayView();\n\n    overlay.onAdd = wrapExceptionLogger(() => {\n      if (this.onAdd === null) return;\n      this.onAdd();\n    });\n\n    overlay.onRemove = wrapExceptionLogger(() => {\n      if (this.onRemove === null) return;\n      this.onRemove();\n    });\n\n    overlay.onDraw = wrapExceptionLogger(this.onDraw.bind(this));\n\n    overlay.onContextRestored = wrapExceptionLogger(\n      this.onContextRestored.bind(this)\n    );\n\n    overlay.onContextLost = wrapExceptionLogger(this.onContextLost.bind(this));\n\n    return overlay;\n  }\n}\n\n// (hopefully) temporary solution to make sure exceptions wont be silently ignored.\nfunction wrapExceptionLogger<T extends Function>(fn: T): T {\n  return ((...args: any[]) => {\n    try {\n      return fn(...args);\n    } catch (err) {\n      console.error(err);\n      throw err;\n    }\n  }) as any;\n}\n"],"names":["sin","Math","cos","pow","sqrt","atan2","asin","sign","degToRad","MathUtils","radToDeg","euclideanModulo","distance","from","to","latFrom","lat","lngFrom","lng","latTo","lngTo","dLat","dLon","lat1","lat2","a","projectionMatrixInverse","Matrix4","ThreeJSOverlayView","referencePoint","overlay","camera","renderer","scene","viewportSize","Vector2","raycaster","Raycaster","onAdd","onRemove","update","this","altitude","initWebGLOverlayView","initScene","PerspectiveCamera","setMap","map","setReferencePoint","getScene","getViewportSize","requestRedraw","raycast","normalizedScreenPoint","objects","options","updateMatrix","recursive","raycasterParameters","copy","projectionMatrix","invert","ray","origin","set","x","y","applyMatrix4","direction","sub","normalize","oldRaycasterParams","params","results","Array","isArray","intersectObjects","intersectObject","latLngAltToVector3","point","target","Vector3","reference","dx","dy","sx","sy","vector3ToLatLngAlt","sceneAnchor","bearing","lngOrigin","latOrigin","bearingRad","radians","latDestination","lngDestination","destination","length","getTrueBearing","z","onContextRestored","stateOptions","gl","WebGL1Renderer","canvas","context","getContextAttributes","autoClear","autoClearDepth","width","height","onContextLost","dispose","onDraw","drawOptions","transformer","getMap","fromArray","fromLatLngAltitude","setViewport","render","resetState","Scene","hemiLight","HemisphereLight","position","dirLight","DirectionalLight","add","google","maps","Error","WebGLOverlayView","wrapExceptionLogger","_this","bind","fn","err","console","error"],"mappings":"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"}