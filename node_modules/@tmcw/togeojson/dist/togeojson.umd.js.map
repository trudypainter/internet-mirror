{"version":3,"file":"togeojson.umd.js","sources":["../lib/lib/shared.ts","../lib/lib/gpx/line.ts","../lib/lib/gpx/extensions.ts","../lib/lib/gpx/coord_pair.ts","../lib/lib/gpx/properties.ts","../lib/lib/gpx.ts","../lib/lib/tcx.ts","../lib/lib/kml/fixColor.ts","../lib/lib/kml/extractStyle.ts","../lib/lib/kml/geometry.ts","../lib/lib/kml/placemark.ts","../lib/lib/kml.ts"],"sourcesContent":["import type { Feature, Geometry } from \"geojson\";\n\nexport function $(element: Element | Document, tagName: string): Element[] {\n  return Array.from(element.getElementsByTagName(tagName));\n}\n\nexport type P = NonNullable<Feature[\"properties\"]>;\nexport type F = Feature<Geometry | null>;\n\nexport type StyleMap = { [key: string]: P };\n\nexport function normalizeId(id: string) {\n  return id[0] === \"#\" ? id : `#${id}`;\n}\n\nexport function $ns(\n  element: Element | Document,\n  tagName: string,\n  ns: string\n): Element[] {\n  return Array.from(element.getElementsByTagNameNS(ns, tagName));\n}\n\n/**\n * get the content of a text node, if any\n */\nexport function nodeVal(node: Element | null) {\n  node?.normalize();\n  return (node && node.textContent) || \"\";\n}\n\n/**\n * Get one Y child of X, if any, otherwise null\n */\nexport function get1(\n  node: Element,\n  tagName: string,\n  callback?: (elem: Element) => unknown\n) {\n  const n = node.getElementsByTagName(tagName);\n  const result = n.length ? n[0] : null;\n  if (result && callback) callback(result);\n  return result;\n}\n\nexport function get(\n  node: Element | null,\n  tagName: string,\n  callback?: (elem: Element, properties: P) => P\n) {\n  const properties: Feature[\"properties\"] = {};\n  if (!node) return properties;\n  const n = node.getElementsByTagName(tagName);\n  const result = n.length ? n[0] : null;\n  if (result && callback) {\n    return callback(result, properties);\n  }\n  return properties;\n}\n\nexport function val1(\n  node: Element,\n  tagName: string,\n  callback: (val: string) => P | void\n): P {\n  const val = nodeVal(get1(node, tagName));\n  if (val && callback) return callback(val) || {};\n  return {};\n}\n\nexport function $num(\n  node: Element,\n  tagName: string,\n  callback: (val: number) => Feature[\"properties\"]\n) {\n  const val = parseFloat(nodeVal(get1(node, tagName)));\n  if (isNaN(val)) return undefined;\n  if (val && callback) return callback(val) || {};\n  return {};\n}\n\nexport function num1(\n  node: Element,\n  tagName: string,\n  callback?: (val: number) => unknown\n) {\n  const val = parseFloat(nodeVal(get1(node, tagName)));\n  if (isNaN(val)) return undefined;\n  if (val && callback) callback(val);\n  return val;\n}\n\nexport function getMulti(node: Element, propertyNames: string[]): P {\n  const properties: P = {};\n  for (const property of propertyNames) {\n    val1(node, property, (val) => {\n      properties[property] = val;\n    });\n  }\n  return properties;\n}\n\nexport function isElement(node: Node | null): node is Element {\n  return node?.nodeType === 1;\n}\n","import { get, P, val1, $num } from \"../shared\";\n\nexport function getLineStyle(node: Element | null) {\n  return get(node, \"line\", (lineStyle) => {\n    const val: P = Object.assign(\n      {},\n      val1(lineStyle, \"color\", (color) => {\n        return { stroke: `#${color}` };\n      }),\n      $num(lineStyle, \"opacity\", (opacity) => {\n        return { \"stroke-opacity\": opacity };\n      }),\n      $num(lineStyle, \"width\", (width) => {\n        // GPX width is in mm, convert to px with 96 px per inch\n        return { \"stroke-width\": (width * 96) / 25.4 };\n      })\n    );\n    return val;\n  });\n}\n","import { isElement, nodeVal } from \"../shared\";\n\nexport type ExtendedValues = [string, string | number][];\n\nexport function getExtensions(node: Element | null): ExtendedValues {\n  let values: [string, string | number][] = [];\n  if (node === null) return values;\n  for (const child of Array.from(node.childNodes)) {\n    if (!isElement(child)) continue;\n    const name = abbreviateName(child.nodeName);\n    if (name === \"gpxtpx:TrackPointExtension\") {\n      // loop again for nested garmin extensions (eg. \"gpxtpx:hr\")\n      values = values.concat(getExtensions(child));\n    } else {\n      // push custom extension (eg. \"power\")\n      const val = nodeVal(child);\n      values.push([name, parseNumeric(val)]);\n    }\n  }\n  return values;\n}\n\nfunction abbreviateName(name: string) {\n  return [\"heart\", \"gpxtpx:hr\", \"hr\"].includes(name) ? \"heart\" : name;\n}\n\nfunction parseNumeric(val: string) {\n  const num = parseFloat(val);\n  return isNaN(num) ? val : num;\n}\n","import { Position } from \"geojson\";\nimport { num1, get1, nodeVal } from \"../shared\";\nimport { ExtendedValues, getExtensions } from \"./extensions\";\n\ninterface CoordPair {\n  coordinates: Position;\n  time: string | null;\n  extendedValues: ExtendedValues;\n}\n\nexport function coordPair(node: Element): CoordPair | null {\n  const ll = [\n    parseFloat(node.getAttribute(\"lon\") || \"\"),\n    parseFloat(node.getAttribute(\"lat\") || \"\"),\n  ];\n\n  if (isNaN(ll[0]) || isNaN(ll[1])) {\n    return null;\n  }\n\n  num1(node, \"ele\", (val) => {\n    ll.push(val);\n  });\n\n  const time = get1(node, \"time\");\n  return {\n    coordinates: ll,\n    time: time ? nodeVal(time) : null,\n    extendedValues: getExtensions(get1(node, \"extensions\")),\n  };\n}\n","import { $, getMulti, nodeVal } from \"../shared\";\n\nexport function extractProperties(node: Element) {\n  const properties = getMulti(node, [\n    \"name\",\n    \"cmt\",\n    \"desc\",\n    \"type\",\n    \"time\",\n    \"keywords\",\n  ]);\n\n  const extensions = Array.from(\n    node.getElementsByTagNameNS(\n      \"http://www.garmin.com/xmlschemas/GpxExtensions/v3\",\n      \"*\"\n    )\n  );\n  for (const child of extensions) {\n    if (child.parentNode?.parentNode === node) {\n      properties[child.tagName.replace(\":\", \"_\")] = nodeVal(child);\n    }\n  }\n\n  const links = $(node, \"link\");\n  if (links.length) {\n    properties.links = links.map((link) =>\n      Object.assign(\n        { href: link.getAttribute(\"href\") },\n        getMulti(link, [\"text\", \"type\"])\n      )\n    );\n  }\n\n  return properties;\n}\n","import type {\n  FeatureCollection,\n  Feature,\n  Point,\n  MultiLineString,\n  LineString,\n  Position,\n} from \"geojson\";\nimport { getLineStyle } from \"./gpx/line\";\nimport { coordPair } from \"./gpx/coord_pair\";\nimport { extractProperties } from \"./gpx/properties\";\nimport { P, $, get1, getMulti } from \"./shared\";\n\n/**\n * Extract points from a trkseg or rte element.\n */\nfunction getPoints(node: Element, pointname: \"trkpt\" | \"rtept\") {\n  const pts = $(node, pointname);\n  const line: Position[] = [];\n  const times = [];\n  const extendedValues: P = {};\n\n  for (let i = 0; i < pts.length; i++) {\n    const c = coordPair(pts[i]);\n    if (!c) {\n      continue;\n    }\n    line.push(c.coordinates);\n    if (c.time) times.push(c.time);\n    for (const [name, val] of c.extendedValues) {\n      const plural =\n        name === \"heart\" ? name : name.replace(\"gpxtpx:\", \"\") + \"s\";\n      if (!extendedValues[plural]) {\n        extendedValues[plural] = Array(pts.length).fill(null);\n      }\n      extendedValues[plural][i] = val;\n    }\n  }\n\n  if (line.length < 2) return; // Invalid line in GeoJSON\n\n  return {\n    line: line,\n    times: times,\n    extendedValues: extendedValues,\n  };\n}\n\n/**\n * Extract a LineString geometry from a rte\n * element.\n */\nfunction getRoute(node: Element): Feature<LineString> | undefined {\n  const line = getPoints(node, \"rtept\");\n  if (!line) return;\n  return {\n    type: \"Feature\",\n    properties: Object.assign(\n      { _gpxType: \"rte\" },\n      extractProperties(node),\n      getLineStyle(get1(node, \"extensions\"))\n    ),\n    geometry: {\n      type: \"LineString\",\n      coordinates: line.line,\n    },\n  };\n}\n\nfunction getTrack(node: Element): Feature<LineString | MultiLineString> | null {\n  const segments = $(node, \"trkseg\");\n  const track = [];\n  const times = [];\n  const extractedLines = [];\n\n  for (const segment of segments) {\n    const line = getPoints(segment, \"trkpt\");\n    if (line) {\n      extractedLines.push(line);\n      if (line.times && line.times.length) times.push(line.times);\n    }\n  }\n\n  if (extractedLines.length === 0) return null;\n\n  const multi = extractedLines.length > 1;\n\n  const properties: Feature[\"properties\"] = Object.assign(\n    { _gpxType: \"trk\" },\n    extractProperties(node),\n    getLineStyle(get1(node, \"extensions\")),\n    times.length\n      ? {\n          coordinateProperties: {\n            times: multi ? times : times[0],\n          },\n        }\n      : {}\n  );\n\n  for (const line of extractedLines) {\n    track.push(line.line);\n    if (!properties.coordinateProperties) {\n      properties.coordinateProperties = {};\n    }\n    const props = properties.coordinateProperties;\n    const entries = Object.entries(line.extendedValues);\n    for (let i = 0; i < entries.length; i++) {\n      const [name, val] = entries[i];\n      if (multi) {\n        if (!props[name]) {\n          props[name] = extractedLines.map((line) =>\n            new Array(line.line.length).fill(null)\n          );\n        }\n        props[name][i] = val;\n      } else {\n        props[name] = val;\n      }\n    }\n  }\n\n  return {\n    type: \"Feature\",\n    properties: properties,\n    geometry: multi\n      ? {\n          type: \"MultiLineString\",\n          coordinates: track,\n        }\n      : {\n          type: \"LineString\",\n          coordinates: track[0],\n        },\n  };\n}\n\n/**\n * Extract a point, if possible, from a given node,\n * which is usually a wpt or trkpt\n */\nfunction getPoint(node: Element): Feature<Point> | null {\n  const properties: Feature[\"properties\"] = Object.assign(\n    extractProperties(node),\n    getMulti(node, [\"sym\"])\n  );\n  const pair = coordPair(node);\n  if (!pair) return null;\n  return {\n    type: \"Feature\",\n    properties,\n    geometry: {\n      type: \"Point\",\n      coordinates: pair.coordinates,\n    },\n  };\n}\n\n/**\n * Convert GPX to GeoJSON incrementally, returning\n * a [Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)\n * that yields output feature by feature.\n */\nexport function* gpxGen(node: Document): Generator<Feature> {\n  for (const track of $(node, \"trk\")) {\n    const feature = getTrack(track);\n    if (feature) yield feature;\n  }\n\n  for (const route of $(node, \"rte\")) {\n    const feature = getRoute(route);\n    if (feature) yield feature;\n  }\n\n  for (const waypoint of $(node, \"wpt\")) {\n    const point = getPoint(waypoint);\n    if (point) yield point;\n  }\n}\n\n/**\n *\n * Convert a GPX document to GeoJSON. The first argument, `doc`, must be a GPX\n * document as an XML DOM - not as a string. You can get this using jQuery's default\n * `.ajax` function or using a bare XMLHttpRequest with the `.response` property\n * holding an XML DOM.\n *\n * The output is a JavaScript object of GeoJSON data, same as `.kml` outputs, with the\n * addition of a `_gpxType` property on each `LineString` feature that indicates whether\n * the feature was encoded as a route (`rte`) or track (`trk`) in the GPX document.\n */\nexport function gpx(node: Document): FeatureCollection {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(gpxGen(node)),\n  };\n}\n","import { Feature, FeatureCollection, Position } from \"geojson\";\nimport { P, $, get, num1, nodeVal, get1 } from \"./shared\";\n\ntype PropertyMapping = readonly [string, string][];\n\nconst EXTENSIONS_NS = \"http://www.garmin.com/xmlschemas/ActivityExtension/v2\";\n\nconst TRACKPOINT_ATTRIBUTES: PropertyMapping = [\n  [\"heartRate\", \"heartRates\"],\n  [\"Cadence\", \"cadences\"],\n  // Extended Trackpoint attributes\n  [\"Speed\", \"speeds\"],\n  [\"Watts\", \"watts\"],\n];\n\nconst LAP_ATTRIBUTES: PropertyMapping = [\n  [\"TotalTimeSeconds\", \"totalTimeSeconds\"],\n  [\"DistanceMeters\", \"distanceMeters\"],\n  [\"MaximumSpeed\", \"maxSpeed\"],\n  [\"AverageHeartRateBpm\", \"avgHeartRate\"],\n  [\"MaximumHeartRateBpm\", \"maxHeartRate\"],\n\n  // Extended Lap attributes\n  [\"AvgSpeed\", \"avgSpeed\"],\n  [\"AvgWatts\", \"avgWatts\"],\n  [\"MaxWatts\", \"maxWatts\"],\n];\n\nfunction getProperties(node: Element, attributeNames: PropertyMapping) {\n  const properties = [];\n\n  for (const [tag, alias] of attributeNames) {\n    let elem = get1(node, tag);\n    if (!elem) {\n      const elements = node.getElementsByTagNameNS(EXTENSIONS_NS, tag);\n      if (elements.length) {\n        elem = elements[0];\n      }\n    }\n    const val = parseFloat(nodeVal(elem));\n    if (!isNaN(val)) {\n      properties.push([alias, val]);\n    }\n  }\n\n  return properties;\n}\n\nfunction coordPair(node: Element) {\n  const ll = [num1(node, \"LongitudeDegrees\"), num1(node, \"LatitudeDegrees\")];\n  if (\n    ll[0] === undefined ||\n    isNaN(ll[0]) ||\n    ll[1] === undefined ||\n    isNaN(ll[1])\n  ) {\n    return null;\n  }\n  const heartRate = get1(node, \"HeartRateBpm\");\n  const time = nodeVal(get1(node, \"Time\"));\n  get1(node, \"AltitudeMeters\", (alt) => {\n    const a = parseFloat(nodeVal(alt));\n    if (!isNaN(a)) {\n      ll.push(a);\n    }\n  });\n  return {\n    coordinates: ll as number[],\n    time: time || null,\n    heartRate: heartRate ? parseFloat(nodeVal(heartRate)) : null,\n    extensions: getProperties(node, TRACKPOINT_ATTRIBUTES),\n  };\n}\n\nfunction getPoints(node: Element) {\n  const pts = $(node, \"Trackpoint\");\n  const line: Position[] = [];\n  const times = [];\n  const heartRates = [];\n  if (pts.length < 2) return null; // Invalid line in GeoJSON\n  const extendedProperties: P = {};\n  const result = { extendedProperties };\n  for (let i = 0; i < pts.length; i++) {\n    const c = coordPair(pts[i]);\n    if (c === null) continue;\n    line.push(c.coordinates);\n    const { time, heartRate, extensions } = c;\n    if (time) times.push(time);\n    if (heartRate) heartRates.push(heartRate);\n    for (const [alias, value] of extensions) {\n      if (!extendedProperties[alias]) {\n        extendedProperties[alias] = Array(pts.length).fill(null);\n      }\n      extendedProperties[alias][i] = value;\n    }\n  }\n  if (line.length < 2) return null;\n  return Object.assign(result, {\n    line: line,\n    times: times,\n    heartRates: heartRates,\n  });\n}\n\nfunction getLap(node: Element): Feature | null {\n  const segments = $(node, \"Track\");\n  const track = [];\n  const times = [];\n  const heartRates = [];\n  const allExtendedProperties = [];\n  let line;\n  const properties: P = Object.assign(\n    Object.fromEntries(getProperties(node, LAP_ATTRIBUTES)),\n    get(node, \"Name\", (nameElement) => {\n      return { name: nodeVal(nameElement) };\n    })\n  );\n\n  for (const segment of segments) {\n    line = getPoints(segment);\n    if (line) {\n      track.push(line.line);\n      if (line.times.length) times.push(line.times);\n      if (line.heartRates.length) heartRates.push(line.heartRates);\n      allExtendedProperties.push(line.extendedProperties);\n    }\n  }\n  for (let i = 0; i < allExtendedProperties.length; i++) {\n    const extendedProperties = allExtendedProperties[i];\n    for (const property in extendedProperties) {\n      if (segments.length === 1) {\n        if (line) {\n          properties[property] = line.extendedProperties[property];\n        }\n      } else {\n        if (!properties[property]) {\n          properties[property] = track.map((track) =>\n            Array(track.length).fill(null)\n          );\n        }\n        properties[property][i] = extendedProperties[property];\n      }\n    }\n  }\n\n  if (track.length === 0) return null;\n\n  if (times.length || heartRates.length) {\n    properties.coordinateProperties = Object.assign(\n      times.length\n        ? {\n            times: track.length === 1 ? times[0] : times,\n          }\n        : {},\n      heartRates.length\n        ? {\n            heart: track.length === 1 ? heartRates[0] : heartRates,\n          }\n        : {}\n    );\n  }\n\n  return {\n    type: \"Feature\",\n    properties: properties,\n    geometry:\n      track.length === 1\n        ? {\n            type: \"LineString\",\n            coordinates: track[0],\n          }\n        : {\n            type: \"MultiLineString\",\n            coordinates: track,\n          },\n  };\n}\n\n/**\n * Incrementally convert a TCX document to GeoJSON. The\n * first argument, `doc`, must be a TCX\n * document as an XML DOM - not as a string.\n */\nexport function* tcxGen(node: Document): Generator<Feature> {\n  for (const lap of $(node, \"Lap\")) {\n    const feature = getLap(lap);\n    if (feature) yield feature;\n  }\n\n  for (const course of $(node, \"Courses\")) {\n    const feature = getLap(course);\n    if (feature) yield feature;\n  }\n}\n\n/**\n * Convert a TCX document to GeoJSON. The first argument, `doc`, must be a TCX\n * document as an XML DOM - not as a string.\n */\nexport function tcx(node: Document): FeatureCollection {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(tcxGen(node)),\n  };\n}\n","import { P } from \"../shared\";\n\nexport function fixColor(v: string, prefix: string): P {\n  const properties: P = {};\n  const colorProp =\n    prefix == \"stroke\" || prefix === \"fill\" ? prefix : prefix + \"-color\";\n  if (v[0] === \"#\") {\n    v = v.substring(1);\n  }\n  if (v.length === 6 || v.length === 3) {\n    properties[colorProp] = \"#\" + v;\n  } else if (v.length === 8) {\n    properties[prefix + \"-opacity\"] = parseInt(v.substring(0, 2), 16) / 255;\n    properties[colorProp] =\n      \"#\" + v.substring(6, 8) + v.substring(4, 6) + v.substring(2, 4);\n  }\n  return properties;\n}\n","import { P, get, num1, nodeVal, val1 } from \"../shared\";\nimport { fixColor } from \"./fixColor\";\n\nfunction numericProperty(node: Element, source: string, target: string): P {\n  const properties: P = {};\n  num1(node, source, (val) => {\n    properties[target] = val;\n  });\n  return properties;\n}\n\nfunction getColor(node: Element, output: string): P {\n  return get(node, \"color\", (elem) => fixColor(nodeVal(elem), output));\n}\n\nexport function extractIcon(node: Element) {\n  return get(node, \"IconStyle\", (iconStyle) => {\n    return Object.assign(\n      getColor(iconStyle, \"icon\"),\n      numericProperty(iconStyle, \"scale\", \"icon-scale\"),\n      numericProperty(iconStyle, \"heading\", \"icon-heading\"),\n      get(iconStyle, \"hotSpot\", (hotspot) => {\n        const left = parseFloat(hotspot.getAttribute(\"x\") || \"\");\n        const top = parseFloat(hotspot.getAttribute(\"y\") || \"\");\n        const xunits = hotspot.getAttribute(\"xunits\") || \"\";\n        const yunits = hotspot.getAttribute(\"yunits\") || \"\";\n        if (!isNaN(left) && !isNaN(top))\n          return {\n            \"icon-offset\": [left, top],\n            \"icon-offset-units\": [xunits, yunits],\n          };\n        return {};\n      }),\n      get(iconStyle, \"Icon\", (icon, properties) => {\n        val1(icon, \"href\", (href) => {\n          properties.icon = href;\n        });\n        return properties;\n      })\n    );\n  });\n}\n\nexport function extractLabel(node: Element) {\n  return get(node, \"LabelStyle\", (labelStyle) => {\n    return Object.assign(\n      getColor(labelStyle, \"label\"),\n      numericProperty(labelStyle, \"scale\", \"label-scale\")\n    );\n  });\n}\n\nexport function extractLine(node: Element) {\n  return get(node, \"LineStyle\", (lineStyle) => {\n    return Object.assign(\n      getColor(lineStyle, \"stroke\"),\n      numericProperty(lineStyle, \"width\", \"stroke-width\")\n    );\n  });\n}\n\nexport function extractPoly(node: Element) {\n  return get(node, \"PolyStyle\", (polyStyle, properties) => {\n    return Object.assign(\n      properties,\n      get(polyStyle, \"color\", (elem) => fixColor(nodeVal(elem), \"fill\")),\n      val1(polyStyle, \"fill\", (fill) => {\n        if (fill === \"0\") return { \"fill-opacity\": 0 };\n      }),\n      val1(polyStyle, \"outline\", (outline) => {\n        if (outline === \"0\") return { \"stroke-opacity\": 0 };\n      })\n    );\n  });\n}\n\nexport function extractStyle(node: Element) {\n  return Object.assign(\n    {},\n    extractPoly(node),\n    extractLine(node),\n    extractLabel(node),\n    extractIcon(node)\n  );\n}\n","import { Position, Point, LineString, Geometry } from \"geojson\";\nimport { $, $ns, nodeVal, get1 } from \"../shared\";\n\nconst removeSpace = /\\s*/g;\nconst trimSpace = /^\\s*|\\s*$/g;\nconst splitSpace = /\\s+/;\n\n/**\n * Get one coordinate from a coordinate array, if any\n */\nexport function coord1(value: string): Position {\n  return value\n    .replace(removeSpace, \"\")\n    .split(\",\")\n    .map(parseFloat)\n    .filter((num) => !isNaN(num))\n    .slice(0, 3);\n}\n\n/**\n * Get all coordinates from a coordinate array as [[],[]]\n */\nexport function coord(value: string): Position[] {\n  return value\n    .replace(trimSpace, \"\")\n    .split(splitSpace)\n    .map(coord1)\n    .filter((coord) => {\n      return coord.length >= 2;\n    });\n}\n\nfunction gxCoords(\n  node: Element\n): { geometry: Point | LineString; times: string[] } | null {\n  let elems = $(node, \"coord\");\n  if (elems.length === 0) {\n    elems = $ns(node, \"coord\", \"*\");\n  }\n\n  const coordinates = elems.map((elem) => {\n    return nodeVal(elem).split(\" \").map(parseFloat);\n  });\n\n  if (coordinates.length === 0) {\n    return null;\n  }\n\n  return {\n    geometry:\n      coordinates.length > 2\n        ? {\n            type: \"LineString\",\n            coordinates,\n          }\n        : {\n            type: \"Point\",\n            coordinates: coordinates[0],\n          },\n    times: $(node, \"when\").map((elem) => nodeVal(elem)),\n  };\n}\n\nexport function fixRing(ring: Position[]) {\n  if (ring.length === 0) return ring;\n  const first = ring[0];\n  const last = ring[ring.length - 1];\n  let equal = true;\n  for (let i = 0; i < Math.max(first.length, last.length); i++) {\n    if (first[i] !== last[i]) {\n      equal = false;\n      break;\n    }\n  }\n  if (!equal) {\n    return ring.concat([ring[0]]);\n  }\n  return ring;\n}\n\nconst GEO_TYPES = [\n  \"Polygon\",\n  \"LineString\",\n  \"Point\",\n  \"Track\",\n  \"gx:Track\",\n] as const;\n\nfunction getCoordinates(node: Element) {\n  return nodeVal(get1(node, \"coordinates\"));\n}\n\ninterface GeometriesAndTimes {\n  geometries: Geometry[];\n  coordTimes: string[][];\n}\n\nexport function getGeometry(node: Element): GeometriesAndTimes {\n  const geometries: Geometry[] = [];\n  const coordTimes = [];\n  for (const t of [\"MultiGeometry\", \"MultiTrack\", \"gx:MultiTrack\"]) {\n    const elem = get1(node, t);\n    if (elem) {\n      return getGeometry(elem);\n    }\n  }\n  for (const geoType of GEO_TYPES) {\n    for (const geomNode of $(node, geoType)) {\n      switch (geoType) {\n        case \"Point\": {\n          const coordinates = coord1(getCoordinates(geomNode));\n          if (coordinates.length >= 2) {\n            geometries.push({\n              type: \"Point\",\n              coordinates,\n            });\n          }\n          break;\n        }\n        case \"LineString\": {\n          const coordinates = coord(getCoordinates(geomNode));\n          if (coordinates.length >= 2) {\n            geometries.push({\n              type: \"LineString\",\n              coordinates,\n            });\n          }\n          break;\n        }\n        case \"Polygon\": {\n          const coords = [];\n          for (const linearRing of $(geomNode, \"LinearRing\")) {\n            const ring = fixRing(coord(getCoordinates(linearRing)));\n            if (ring.length >= 4) {\n              coords.push(ring);\n            }\n          }\n          if (coords.length) {\n            geometries.push({\n              type: \"Polygon\",\n              coordinates: coords,\n            });\n          }\n          break;\n        }\n        case \"Track\":\n        case \"gx:Track\": {\n          const gx = gxCoords(geomNode);\n          if (!gx) break;\n          const { times, geometry } = gx;\n          geometries.push(geometry);\n          if (times.length) coordTimes.push(times);\n          break;\n        }\n      }\n    }\n  }\n  return {\n    geometries,\n    coordTimes,\n  };\n}\n","import { Feature, Geometry } from \"geojson\";\nimport {\n  StyleMap,\n  P,\n  $,\n  get,\n  get1,\n  getMulti,\n  nodeVal,\n  normalizeId,\n  val1,\n} from \"../shared\";\nimport { extractStyle } from \"./extractStyle\";\nimport { getGeometry } from \"./geometry\";\n\nfunction extractExtendedData(node: Element) {\n  return get(node, \"ExtendedData\", (extendedData, properties) => {\n    for (const data of $(extendedData, \"Data\")) {\n      properties[data.getAttribute(\"name\") || \"\"] = nodeVal(\n        get1(data, \"value\")\n      );\n    }\n    for (const simpleData of $(extendedData, \"SimpleData\")) {\n      properties[simpleData.getAttribute(\"name\") || \"\"] = nodeVal(simpleData);\n    }\n    return properties;\n  });\n}\n\nfunction geometryListToGeometry(geometries: Geometry[]): Geometry | null {\n  return geometries.length === 0\n    ? null\n    : geometries.length === 1\n    ? geometries[0]\n    : {\n        type: \"GeometryCollection\",\n        geometries,\n      };\n}\n\nfunction extractTimeSpan(node: Element): P {\n  return get(node, \"TimeSpan\", (timeSpan) => {\n    return {\n      timespan: {\n        begin: nodeVal(get1(timeSpan, \"begin\")),\n        end: nodeVal(get1(timeSpan, \"end\")),\n      },\n    };\n  });\n}\n\nfunction extractTimeStamp(node: Element): P {\n  return get(node, \"TimeStamp\", (timeStamp) => {\n    return { timestamp: nodeVal(get1(timeStamp, \"when\")) };\n  });\n}\n\nfunction extractCascadedStyle(node: Element, styleMap: StyleMap): P {\n  return val1(node, \"styleUrl\", (styleUrl) => {\n    styleUrl = normalizeId(styleUrl);\n    if (styleMap[styleUrl]) {\n      return Object.assign({ styleUrl }, styleMap[styleUrl]);\n    }\n    // For backward-compatibility. Should we still include\n    // styleUrl even if it's not resolved?\n    return { styleUrl };\n  });\n}\n\nfunction getMaybeHTMLDescription(node: Element) {\n  const descriptionNode = get1(node, \"description\");\n  for (const c of Array.from(descriptionNode?.childNodes || [])) {\n    if (c.nodeType === 4) {\n      return {\n        description: {\n          \"@type\": \"html\",\n          value: nodeVal(c as Element),\n        },\n      };\n    }\n  }\n  return {};\n}\n\nexport function getPlacemark(\n  node: Element,\n  styleMap: StyleMap\n): Feature<Geometry | null> {\n  const { coordTimes, geometries } = getGeometry(node);\n\n  const feature: Feature<Geometry | null> = {\n    type: \"Feature\",\n    geometry: geometryListToGeometry(geometries),\n    properties: Object.assign(\n      getMulti(node, [\n        \"name\",\n        \"address\",\n        \"visibility\",\n        \"open\",\n        \"phoneNumber\",\n        \"description\",\n      ]),\n      getMaybeHTMLDescription(node),\n      extractCascadedStyle(node, styleMap),\n      extractStyle(node),\n      extractExtendedData(node),\n      extractTimeSpan(node),\n      extractTimeStamp(node),\n      coordTimes.length\n        ? {\n            coordinateProperties: {\n              times: coordTimes.length === 1 ? coordTimes[0] : coordTimes,\n            },\n          }\n        : {}\n    ),\n  };\n\n  if (feature.properties?.visibility !== undefined) {\n    feature.properties.visibility = feature.properties.visibility !== \"0\";\n  }\n\n  const id = node.getAttribute(\"id\");\n  if (id !== null && id !== \"\") feature.id = id;\n  return feature;\n}\n","import { extractStyle } from \"./kml/extractStyle\";\nimport { getPlacemark } from \"./kml/placemark\";\nimport { FeatureCollection, Geometry } from \"geojson\";\nimport {\n  $,\n  StyleMap,\n  P,\n  F,\n  val1,\n  nodeVal,\n  isElement,\n  normalizeId,\n} from \"./shared\";\n\n/**\n * A folder including metadata. Folders\n * may contain other folders or features,\n * or nothing at all.\n */\nexport interface Folder {\n  type: \"folder\";\n  /**\n   * Standard values:\n   *\n   * * \"name\",\n   * * \"visibility\",\n   * * \"open\",\n   * * \"address\",\n   * * \"description\",\n   * * \"phoneNumber\",\n   * * \"visibility\",\n   */\n  meta: {\n    [key: string]: unknown;\n  };\n  children: Array<Folder | F>;\n}\n\n/**\n * A nested folder structure, represented\n * as a tree with folders and features.\n */\nexport interface Root {\n  type: \"root\";\n  children: Array<Folder | F>;\n}\n\ntype TreeContainer = Root | Folder;\n\nfunction getStyleId(style: Element) {\n  let id = style.getAttribute(\"id\");\n  const parentNode = style.parentNode;\n  if (\n    !id &&\n    isElement(parentNode) &&\n    parentNode.localName === \"CascadingStyle\"\n  ) {\n    id = parentNode.getAttribute(\"kml:id\") || parentNode.getAttribute(\"id\");\n  }\n  return normalizeId(id || \"\");\n}\n\nfunction buildStyleMap(node: Document): StyleMap {\n  const styleMap: StyleMap = {};\n  for (const style of $(node, \"Style\")) {\n    styleMap[getStyleId(style)] = extractStyle(style);\n  }\n  for (const map of $(node, \"StyleMap\")) {\n    const id = normalizeId(map.getAttribute(\"id\") || \"\");\n    val1(map, \"styleUrl\", (styleUrl) => {\n      styleUrl = normalizeId(styleUrl);\n      if (styleMap[styleUrl]) {\n        styleMap[id] = styleMap[styleUrl];\n      }\n    });\n  }\n  return styleMap;\n}\n\nconst FOLDER_PROPS = [\n  \"name\",\n  \"visibility\",\n  \"open\",\n  \"address\",\n  \"description\",\n  \"phoneNumber\",\n  \"visibility\",\n] as const;\n\nfunction getFolder(node: Element): Folder {\n  const meta: P = {};\n\n  for (const child of Array.from(node.childNodes)) {\n    if (isElement(child) && FOLDER_PROPS.includes(child.tagName as any)) {\n      meta[child.tagName] = nodeVal(child);\n    }\n  }\n\n  return {\n    type: \"folder\",\n    meta,\n    children: [],\n  };\n}\n\n/**\n * Yield a nested tree with KML folder structure\n *\n * This generates a tree with the given structure:\n *\n * ```js\n * {\n *   \"type\": \"root\",\n *   \"children\": [\n *     {\n *       \"type\": \"folder\",\n *       \"meta\": {\n *         \"name\": \"Test\"\n *       },\n *       \"children\": [\n *          // ...features and folders\n *       ]\n *     }\n *     // ...features\n *   ]\n * }\n * ```\n */\nexport function kmlWithFolders(node: Document): Root {\n  const styleMap = buildStyleMap(node);\n\n  // atomic geospatial types supported by KML - MultiGeometry is\n  // handled separately\n  // all root placemarks in the file\n  const placemarks = [];\n  const tree: Root = { type: \"root\", children: [] };\n\n  function traverse(\n    node: Document | ChildNode | Element,\n    pointer: TreeContainer\n  ) {\n    if (isElement(node)) {\n      switch (node.tagName) {\n        case \"Placemark\": {\n          placemarks.push(node);\n          const placemark = getPlacemark(node, styleMap);\n          if (placemark) {\n            pointer.children.push(placemark);\n          }\n          break;\n        }\n        case \"Folder\": {\n          const folder = getFolder(node);\n          pointer.children.push(folder);\n          pointer = folder;\n          break;\n        }\n      }\n    }\n\n    if (node.childNodes) {\n      for (let i = 0; i < node.childNodes.length; i++) {\n        traverse(node.childNodes[i], pointer);\n      }\n    }\n  }\n\n  traverse(node, tree);\n\n  return tree;\n}\n\n/**\n * Convert KML to GeoJSON incrementally, returning\n * a [Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)\n * that yields output feature by feature.\n */\nexport function* kmlGen(node: Document): Generator<F> {\n  const styleMap = buildStyleMap(node);\n  for (const placemark of $(node, \"Placemark\")) {\n    const feature = getPlacemark(placemark, styleMap);\n    if (feature) yield feature;\n  }\n}\n\n/**\n * Convert a KML document to GeoJSON. The first argument, `doc`, must be a KML\n * document as an XML DOM - not as a string. You can get this using jQuery's default\n * `.ajax` function or using a bare XMLHttpRequest with the `.response` property\n * holding an XML DOM.\n *\n * The output is a JavaScript object of GeoJSON data. You can convert it to a string\n * with [JSON.stringify](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)\n * or use it directly in libraries.\n */\nexport function kml(node: Document): FeatureCollection<Geometry | null> {\n  return {\n    type: \"FeatureCollection\",\n    features: Array.from(kmlGen(node)),\n  };\n}\n"],"names":["$","element","tagName","Array","from","getElementsByTagName","normalizeId","id","nodeVal","node","normalize","textContent","get1","callback","n","result","length","get","properties","val1","val","$num","parseFloat","isNaN","num1","getMulti","propertyNames","property","isElement","nodeType","getLineStyle","lineStyle","Object","assign","color","stroke","opacity","width","getExtensions","values","child","childNodes","name","abbreviateName","nodeName","concat","push","parseNumeric","includes","num","coordPair","ll","getAttribute","time","coordinates","extendedValues","extractProperties","extensions","getElementsByTagNameNS","parentNode","replace","links","map","link","href","getPoints","pointname","pts","line","times","i","c","plural","fill","getRoute","type","_gpxType","geometry","getTrack","segments","track","extractedLines","segment","multi","coordinateProperties","props","entries","getPoint","pair","gpxGen","feature","route","waypoint","point","TRACKPOINT_ATTRIBUTES","LAP_ATTRIBUTES","getProperties","attributeNames","tag","alias","elem","elements","undefined","heartRate","alt","a","heartRates","extendedProperties","value","getLap","allExtendedProperties","fromEntries","nameElement","heart","tcxGen","lap","course","fixColor","v","prefix","colorProp","substring","parseInt","numericProperty","source","target","getColor","output","extractStyle","polyStyle","outline","extractPoly","extractLine","labelStyle","extractLabel","iconStyle","hotspot","left","top","xunits","yunits","icon","extractIcon","removeSpace","trimSpace","splitSpace","coord1","split","filter","slice","coord","gxCoords","elems","ns","fixRing","ring","first","last","equal","Math","max","GEO_TYPES","getCoordinates","getGeometry","geometries","coordTimes","t","geoType","geomNode","coords","linearRing","gx","extractExtendedData","extendedData","data","simpleData","geometryListToGeometry","extractTimeSpan","timeSpan","timespan","begin","end","extractTimeStamp","timeStamp","timestamp","extractCascadedStyle","styleMap","styleUrl","getMaybeHTMLDescription","descriptionNode","description","getPlacemark","visibility","getStyleId","style","localName","buildStyleMap","FOLDER_PROPS","kmlGen","placemark","features","tree","children","traverse","pointer","folder","meta","getFolder"],"mappings":"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"}